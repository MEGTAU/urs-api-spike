<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Relationship Server Spike</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 2em;
        }

        h1 {
            text-align: center;
        }

        h2 {
            margin-top: 2em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1em;
        }

        th, td {
            border: 1px solid #ccc;
            padding: 0.5em;
            text-align: left;
        }

        th {
            background-color: #f4f4f4;
        }

        /* Style the tab */
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
        }

        /* Style the buttons that are used to open the tab content */
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
        }

        /* Change background color of buttons on hover */
        .tab button:hover {
            background-color: #ddd;
        }

        /* Create an active/current tablink class */
        .tab button.active {
            background-color: #ccc;
        }

        /* Style the tab content */
        .tabcontent {
            display: none;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-top: none;
        }

        .tabcontent {
            animation: fadeEffect 1s; /* Fading effect takes 1 second */
        }

        /* Go from zero to full opacity */
        @keyframes fadeEffect {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
    </style>
</head>
<body>
<h1>Universal Relationship Server Spike</h1>

<!--    <h2>Pets</h2>-->
<!--    <table id="pets-table">-->
<!--        <thead>-->
<!--            <tr>-->
<!--                <th>ID</th>-->
<!--                <th>Name</th>-->
<!--                <th>Status</th>-->
<!--            </tr>-->
<!--        </thead>-->
<!--        <tbody>-->
<!--            &lt;!&ndash; Pet data will be inserted here &ndash;&gt;-->
<!--        </tbody>-->
<!--    </table>-->

<!--    <h2>Store Inventory</h2>-->
<!--    <table id="inventory-table">-->
<!--        <thead>-->
<!--            <tr>-->
<!--                <th>Status</th>-->
<!--                <th>Quantity</th>-->
<!--            </tr>-->
<!--        </thead>-->
<!--        <tbody>-->
<!--            &lt;!&ndash; Inventory data will be inserted here &ndash;&gt;-->
<!--        </tbody>-->
<!--    </table>-->


<!-- Tab links -->
<div class="tab">
    <button class="tablinks" onclick="openTab(event, 'About')" id="defaultOpen">About</button>
    <button class="tablinks" onclick="openTab(event, 'Contacts/Persons')">Contacts/Persons</button>
    <button class="tablinks" onclick="openTab(event, 'Organisations')">Organisations</button>
    <button class="tablinks" onclick="openTab(event, 'Relationships')">Relationships</button>
    <button class="tablinks" onclick="openTab(event, 'Interactions')">Interactions</button>
</div>

<!-- Tab content -->
<div id="About" class="tabcontent">
    <h3>About</h3>

    <ul>
        <li>
            <a href="http://localhost:8080/docs">Swagger UI</a>
        </li>
        <li>
            <a href="http://localhost:8080/openapi">Raw Open API specification</a>
        </li>
    </ul>

    <h2>Todos</h2>
    <ul>
        <li>Implement authentication and authorisation</li>
        <li>Implement pagination</li>
        <li>Implement sorting and filtering</li>
        <li>Implement search</li>
        <li>Implement more relationship types</li>
        <li>Implement more profile types</li>
        <li>Implement more organisation types</li>
        <li>Implement more contact/person fields</li>
        <li>Implement more organisation fields</li>
        <li>Implement more relationship fields</li>
        <li>Improve UI/UX</li>
        <li>Add tests</li>
        <li>Add CI/CD</li>
    </ul>

</div>

<div id="Contacts/Persons" class="tabcontent">
    <h3>Contacts/Persons</h3>
    <p>A `Contact/Person` resource represents the "digital soul". Each `Contact/Person` may have multiple profiles
        (e.g. `jobseeker`) associated with them.</p>
    <p>TODO Add table</p>
</div>

<div id="Organisations" class="tabcontent">
    <h3>Organisations</h3>
    <p>This tab displays organisations, such as education providers and employers.</p>
    <button onclick="document.getElementById('import-organisations-input').click()">Import from CSV</button>
    <input type="file" id="import-organisations-input" onchange="importOrganisations(this.files[0])" style="display: none;" accept=".csv">
    <button onclick="exportOrganisations()">Export to CSV</button>
    <table id="organisations-table">
        <thead>
            <tr>
                <th>ID</th>
                <th>Legal Name</th>
                <th>Trading Name</th>
                <th>Type</th>
                <th>ABN</th>
                <th>Employer ID</th>
                <th>Worksite Address</th>
                <th>Worksite State</th>
            </tr>
        </thead>
        <tbody>
            <!-- Organisation data will be inserted here -->
        </tbody>
    </table>
</div>

<div id="Relationships" class="tabcontent">
    <h3>Relationships</h3>
    <p>This tab displays the various relationships</p>
    <button onclick="document.getElementById('import-relationships-input').click()">Import from CSV</button>
    <input type="file" id="import-relationships-input" onchange="importRelationships(this.files[0])" style="display: none;" accept=".csv">
    <button onclick="exportRelationships()">Export to CSV</button>
    <table id="relationships-table">
        <thead>
            <tr>
                <th>ID</th>
                <th>Created At</th>
                <th>Last Confirmed At</th>
                <th>Ended At</th>
                <th>Primary Party</th>
                <th>Related Parties</th>
                <th>Type</th>
            </tr>
        </thead>
        <tbody>
            <!-- Relationship data will be inserted here -->
        </tbody>
    </table>
</div>

<div id="Interactions" class="tabcontent">
    <h3>Interactions</h3>
    <p>This tab displays interactions.</p>
    <button onclick="document.getElementById('import-interactions-input').click()">Import from CSV</button>
    <input type="file" id="import-interactions-input" onchange="importInteractions(this.files[0])" style="display: none;" accept=".csv">
    <button onclick="exportInteractions()">Export to CSV</button>
    <table id="interactions-table">
        <thead>
            <tr>
                <th>ID</th>
                <th>Created At</th>
                <th>Contact ID</th>
                <th>Profile ID</th>
                <th>Interaction Type</th>
                <th>Payload</th>
            </tr>
        </thead>
        <tbody>
            <!-- Interaction data will be inserted here -->
        </tbody>
    </table>
</div>

<script>
    document.getElementById("defaultOpen").click();

    function openTab(evt, cityName) {
        // Declare all variables
        var i, tabcontent, tablinks;

        // Get all elements with class="tabcontent" and hide them
        tabcontent = document.getElementsByClassName("tabcontent");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
        }

        // Get all elements with class="tablinks" and remove the class "active"
        tablinks = document.getElementsByClassName("tablinks");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }

        // Show the current tab, and add an "active" class to the button that opened the tab
        document.getElementById(cityName).style.display = "block";
        evt.currentTarget.className += " active";
    }
</script>
<script>
    let organisationData = []; // To store fetched organisations
    let interactionData = []; // To store fetched interactions
    let relationshipData = []; // To store fetched relationships

    function downloadCSV(data, filename) {
        const csvRows = [];
        // Get the headers
        const headers = Object.keys(data[0]);
        csvRows.push(headers.join(','));

        // Loop over the rows
        for (const row of data) {
            const values = headers.map(header => {
                const escaped = ('' + row[header]).replace(/"/g, '"');
                return `"${escaped}"`;
            });
            csvRows.push(values.join(','));
        }

        const blob = new Blob([csvRows.join('\n')], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.setAttribute('hidden', '');
        a.setAttribute('href', url);
        a.setAttribute('download', filename);
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    function parseCSV(csv) {
        const lines = csv.split('\n');
        const result = [];
        const headers = lines[0].match(/(".*?"|[^,]+)(?=\s*,|\s*$)/g).map(h => h.trim().replace(/^"|"$/g, ''));

        for (let i = 1; i < lines.length; i++) {
            if (!lines[i]) continue;
            const obj = {};
            const currentline = lines[i].match(/(".*?"|[^,]+)(?=\s*,|\s*$)/g);
            if (!currentline) continue;

            for (let j = 0; j < headers.length; j++) {
                obj[headers[j]] = currentline[j].trim().replace(/^"|"$/g, '');
            }
            result.push(obj);
        }
        return result;
    }


    function uploadCSV(file, onUpload) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const text = e.target.result;
            const data = parseCSV(text);
            onUpload(data);
        };
        reader.readAsText(file);
    }

    async function importOrganisations(file) {
        if (!file) return;

        uploadCSV(file, async (organisations) => {
            // The CSV data is flattened, we need to un-flatten it to match the API
            const unflattenedData = organisations.map(org => ({
                legalName: org.legalName,
                tradingName: org.tradingName,
                organisationType: org.organisationType,
                abn: org.abn,
                employer: org.employerId ? { employerId: org.employerId } : null,
                worksite: (org.worksiteAddress || org.worksiteState) ? { address: org.worksiteAddress, state: org.worksiteState } : null
            }));

            try {
                const response = await fetch('/api/v1/organisations/bulk', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(unflattenedData)
                });

                if (response.ok) {
                    alert('Organisations imported successfully!');
                    fetchOrganisations(); // Refresh the table
                } else {
                    const error = await response.json();
                    alert('Error importing organisations: ' + (error.message || 'Unknown error'));
                    console.error('Error importing organisations:', error);
                }
            } catch (error) {
                alert('Error importing organisations: ' + error.message);
                console.error('Error importing organisations:', error);
            }
        });
    }

    async function exportOrganisations() {
        // We can use the already fetched data. If not available, fetch it.
        if (organisationData.length === 0) {
            await fetchOrganisations();
        }
        
        // Flatten the data for CSV export
        const flattenedData = organisationData.map(org => ({
            id: org.id,
            legalName: org.legalName,
            tradingName: org.tradingName,
            organisationType: org.organisationType,
            abn: org.abn,
            employerId: org.employer ? org.employer.employerId : '',
            worksiteAddress: org.worksite ? org.worksite.address : '',
            worksiteState: org.worksite ? org.worksite.state : ''
        }));

        downloadCSV(flattenedData, 'organisations.csv');
    }

    async function fetchOrganisations() {
        const organisationsTable = document.querySelector('#organisations-table tbody');
        try {
            const response = await fetch('/api/v1/organisations');
            if (response.ok) {
                const organisationList = await response.json();
                organisationData = organisationList.entries; // Store the data
                
                // Clear existing rows
                organisationsTable.innerHTML = '';

                organisationData.forEach(org => {
                    const row = organisationsTable.insertRow();
                    row.insertCell().textContent = org.id;
                    row.insertCell().textContent = org.legalName;
                    row.insertCell().textContent = org.tradingName;
                    row.insertCell().textContent = org.organisationType;
                    row.insertCell().textContent = org.abn;
                    row.insertCell().textContent = org.employer ? org.employer.employerId : '';
                    row.insertCell().textContent = org.worksite ? org.worksite.address : '';
                    row.insertCell().textContent = org.worksite ? org.worksite.state : '';
                });
            }
        } catch (error) {
            console.error('Error fetching organisations:', error);
        }
    }

    async function importInteractions(file) {
        if (!file) return;

        uploadCSV(file, async (interactions) => {
            const interactionsToImport = interactions.map(interaction => ({
                createdAt: interaction.createdAt,
                contactId: interaction.contactId,
                profileId: interaction.profileId,
                interactionType: interaction.interactionType,
                payload: JSON.parse(interaction.payload) // Assuming payload is a JSON string in the CSV
            }));

            try {
                const response = await fetch('/api/v1/interactions/bulk', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(interactionsToImport)
                });

                if (response.ok) {
                    alert('Interactions imported successfully!');
                    fetchInteractions(); // Refresh the table
                } else {
                    const error = await response.json();
                    alert('Error importing interactions: ' + (error.message || 'Unknown error'));
                    console.error('Error importing interactions:', error);
                }
            } catch (error) {
                alert('Error importing interactions: ' + error.message);
                console.error('Error importing interactions:', error);
            }
        });
    }

    async function exportInteractions() {
        if (interactionData.length === 0) {
            await fetchInteractions();
        }
        
        const dataToExport = interactionData.map(interaction => ({
            id: interaction.id,
            createdAt: interaction.createdAt,
            contactId: interaction.contactId,
            profileId: interaction.profileId,
            interactionType: interaction.interactionType,
            payload: JSON.stringify(interaction.payload)
        }));

        downloadCSV(dataToExport, 'interactions.csv');
    }

    async function fetchInteractions() {
        const interactionsTable = document.querySelector('#interactions-table tbody');
        try {
            const response = await fetch('/api/v1/interactions');
            if (response.ok) {
                const interactionList = await response.json();
                interactionData = interactionList.entries; // Store the data
                
                // Clear existing rows
                interactionsTable.innerHTML = '';

                interactionData.forEach(interaction => {
                    const row = interactionsTable.insertRow();
                    row.insertCell().textContent = interaction.id;
                    row.insertCell().textContent = interaction.createdAt;
                    row.insertCell().textContent = interaction.contactId;
                    row.insertCell().textContent = interaction.profileId;
                    row.insertCell().textContent = interaction.interactionType;
                    row.insertCell().textContent = JSON.stringify(interaction.payload);
                });
            }
        } catch (error) {
            console.error('Error fetching interactions:', error);
        }
    }

    async function importRelationships(file) {
        if (!file) return;

        uploadCSV(file, async (relationships) => {
            const relationshipsToImport = relationships.map(relationship => ({
                createdAt: relationship.createdAt,
                lastConfirmAt: relationship.lastConfirmAt,
                endedAt: relationship.endedAt,
                primaryParty: relationship.primaryParty,
                relatedParties: relationship.relatedParties.split('|'), // Assuming they are pipe-separated in the CSV
                type: relationship.type
            }));

            try {
                const response = await fetch('/api/v1/relationships/bulk', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(relationshipsToImport)
                });

                if (response.ok) {
                    alert('Relationships imported successfully!');
                    fetchRelationships(); // Refresh the table
                } else {
                    const error = await response.json();
                    alert('Error importing relationships: ' + (error.message || 'Unknown error'));
                    console.error('Error importing relationships:', error);
                }
            } catch (error) {
                alert('Error importing relationships: ' + error.message);
                console.error('Error importing relationships:', error);
            }
        });
    }

    async function exportRelationships() {
        if (relationshipData.length === 0) {
            await fetchRelationships();
        }
        
        const dataToExport = relationshipData.map(relationship => ({
            id: relationship.id,
            createdAt: relationship.createdAt,
            lastConfirmAt: relationship.lastConfirmAt,
            endedAt: relationship.endedAt,
            primaryParty: relationship.primaryParty,
            relatedParties: relationship.relatedParties.join('|'), // Pipe-separate for CSV
            type: relationship.type
        }));

        downloadCSV(dataToExport, 'relationships.csv');
    }

    async function fetchRelationships() {
        const relationshipsTable = document.querySelector('#relationships-table tbody');
        try {
            const response = await fetch('/api/v1/relationships');
            if (response.ok) {
                const relationshipList = await response.json();
                relationshipData = relationshipList.entries; // Store the data
                
                // Clear existing rows
                relationshipsTable.innerHTML = '';

                relationshipData.forEach(relationship => {
                    const row = relationshipsTable.insertRow();
                    row.insertCell().textContent = relationship.id;
                    row.insertCell().textContent = relationship.createdAt;
                    row.insertCell().textContent = relationship.lastConfirmAt;
                    row.insertCell().textContent = relationship.endedAt;
                    row.insertCell().textContent = relationship.primaryParty;
                    row.insertCell().textContent = relationship.relatedParties.join(', ');
                    row.insertCell().textContent = relationship.type;
                });
            }
        } catch (error) {
            console.error('Error fetching relationships:', error);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        fetchOrganisations();
        fetchInteractions();
        fetchRelationships();
    });
</script>
<!--    <script>-->
<!--        async function fetchPets() {-->
<!--            const petsTable = document.querySelector('#pets-table tbody');-->
<!--            const statuses = ['available', 'pending', 'sold'];-->
<!--            -->
<!--            for (const status of statuses) {-->
<!--                try {-->
<!--                    const response = await fetch(`/api/v3/pet/findByStatus?status=${status}`);-->
<!--                    if (response.ok) {-->
<!--                        const pets = await response.json();-->
<!--                        pets.forEach(pet => {-->
<!--                            const row = petsTable.insertRow();-->
<!--                            row.insertCell().textContent = pet.id;-->
<!--                            row.insertCell().textContent = pet.name;-->
<!--                            row.insertCell().textContent = pet.status;-->
<!--                        });-->
<!--                    }-->
<!--                } catch (error) {-->
<!--                    console.error(`Error fetching pets with status ${status}:`, error);-->
<!--                }-->
<!--            }-->
<!--        }-->

<!--        async function fetchInventory() {-->
<!--            const inventoryTable = document.querySelector('#inventory-table tbody');-->
<!--            try {-->
<!--                const response = await fetch('/api/v3/store/inventory');-->
<!--                if (response.ok) {-->
<!--                    const inventory = await response.json();-->
<!--                    for (const status in inventory) {-->
<!--                        const row = inventoryTable.insertRow();-->
<!--                        row.insertCell().textContent = status;-->
<!--                        row.insertCell().textContent = inventory[status];-->
<!--                    }-->
<!--                }-->
<!--            } catch (error) {-->
<!--                console.error('Error fetching inventory:', error);-->
<!--            }-->
<!--        }-->

<!--        document.addEventListener('DOMContentLoaded', () => {-->
<!--            fetchPets();-->
<!--            fetchInventory();-->
<!--        });-->
<!--    </script>-->
</body>
</html>
