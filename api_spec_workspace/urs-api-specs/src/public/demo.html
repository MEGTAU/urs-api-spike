<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Relationship Server Spike</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 2em;
        }

        h1 {
            text-align: center;
        }

        h2 {
            margin-top: 2em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1em;
        }

        th, td {
            border: 1px solid #ccc;
            padding: 0.5em;
            text-align: left;
        }

        th {
            background-color: #f4f4f4;
        }

        /* Style the tab */
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
        }

        /* Style the buttons that are used to open the tab content */
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
        }

        /* Change background color of buttons on hover */
        .tab button:hover {
            background-color: #ddd;
        }

        /* Create an active/current tablink class */
        .tab button.active {
            background-color: #ccc;
        }

        /* Style the tab content */
        .tabcontent {
            display: none;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-top: none;
        }

        .tabcontent {
            animation: fadeEffect 1s; /* Fading effect takes 1 second */
        }

        /* Go from zero to full opacity */
        @keyframes fadeEffect {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
</head>
<body>
<h1>Universal Relationship Server Spike</h1>

<!--    <h2>Pets</h2>-->
<!--    <table id="pets-table">-->
<!--        <thead>-->
<!--            <tr>-->
<!--                <th>ID</th>-->
<!--                <th>Name</th>-->
<!--                <th>Status</th>-->
<!--            </tr>-->
<!--        </thead>-->
<!--        <tbody>-->
<!--            &lt;!&ndash; Pet data will be inserted here &ndash;&gt;-->
<!--        </tbody>-->
<!--    </table>-->

<!--    <h2>Store Inventory</h2>-->
<!--    <table id="inventory-table">-->
<!--        <thead>-->
<!--            <tr>-->
<!--                <th>Status</th>-->
<!--                <th>Quantity</th>-->
<!--            </tr>-->
<!--        </thead>-->
<!--        <tbody>-->
<!--            &lt;!&ndash; Inventory data will be inserted here &ndash;&gt;-->
<!--        </tbody>-->
<!--    </table>-->


<!-- Tab links -->
<div class="tab">
    <button class="tablinks" onclick="openTab(event, 'About')" id="defaultOpen">About</button>
    <button class="tablinks" onclick="openTab(event, 'Contacts/Persons')">Contacts/Persons</button>
    <button class="tablinks" onclick="openTab(event, 'Organisations')">Organisations</button>
    <button class="tablinks" onclick="openTab(event, 'Relationships')">Relationships</button>
    <button class="tablinks" onclick="openTab(event, 'Interactions')">Interactions</button>
</div>

<!-- Tab content -->
<div id="About" class="tabcontent">
    <h3>About</h3>

    <ul>
        <li>
            <a href="http://localhost:8080/docs">Swagger UI</a>
        </li>
        <li>
            <a href="http://localhost:8080/openapi">Raw Open API specification</a>
        </li>
    </ul>

    <h2>Todos</h2>
    <ul>
        <li>Implement authentication and authorisation</li>
        <li>Implement pagination</li>
        <li>Implement sorting and filtering</li>
        <li>Implement search</li>
        <li>Implement more relationship types</li>
        <li>Implement more profile types</li>
        <li>Implement more organisation types</li>
        <li>Implement more contact/person fields</li>
        <li>Implement more organisation fields</li>
        <li>Implement more relationship fields</li>
        <li>Improve UI/UX</li>
        <li>Add tests</li>
        <li>Add CI/CD</li>
    </ul>

</div>

<div id="Contacts/Persons" class="tabcontent">
    <h3>Contacts/Persons</h3>
    <p>A `Contact/Person` resource represents the "digital soul". Each `Contact/Person` may have multiple profiles
        (e.g. `jobseeker`) associated with them.</p>
    <p>This table displays a "wide view" that contains both the core PIU facet of the person/contact as well as the various profiles associated with the individual.</p>
    <button onclick="exportContacts()">Export to CSV</button>
    <table id="contacts-table">
        <thead>
        <tr>
            <th>ID</th>
            <th>First Name</th>
            <th>Last Name</th>
            <th>Email</th>
            <th>Phone</th>
            <th>Created At</th>
            <th>Last Seen At</th>
            <th>USI</th>
            <th>LUI</th>
            <th>TFN</th>
            <th>VSN</th>
            <th>WorkReady Participant Number</th>
            <th>SACE Student Id</th>
            <th>Profile ID</th>
            <th>Profile Type</th>
            <th>Started At</th>
            <th>Completed At</th>
            <th>Is Active</th>
            <th>Profile Information</th>
        </tr>
        </thead>
        <tbody>
        <!-- Contact data will be inserted here -->
        </tbody>
    </table>

    <h3>Analyses</h3>
    <button onclick="exportAnalyses()">Export Analyses to CSV</button>
    <table id="analyses-table">
        <thead>
        <tr>
            <th>Contact ID</th>
            <th>First Name</th>
            <th>Last Name</th>
            <th>Analysis ID</th>
            <th>Type</th>
            <th>Date</th>
            <th>Result</th>
            <th>Notes</th>
        </tr>
        </thead>
        <tbody>
        <!-- Analysis data will be inserted here -->
        </tbody>
    </table>

    <h3>System Links</h3>
    <button onclick="exportSystemLinks()">Export System Links to CSV</button>
    <table id="system-links-table">
        <thead>
        <tr>
            <th>Contact ID</th>
            <th>First Name</th>
            <th>Last Name</th>
            <th>System Link ID</th>
            <th>System Name</th>
            <th>System ID</th>
            <th>URL</th>
        </tr>
        </thead>
        <tbody>
        <!-- System Link data will be inserted here -->
        </tbody>
    </table>
</div>

<div id="Organisations" class="tabcontent">
    <h3>Organisations</h3>
    <p>This tab displays organisations, such as education providers and employers.</p>
    <button onclick="document.getElementById('import-organisations-input').click()">Import from CSV</button>
    <input type="file" id="import-organisations-input" onchange="importOrganisations(this.files[0])"
           style="display: none;" accept=".csv">
    <button onclick="exportOrganisations()">Export to CSV</button>
    <table id="organisations-table">
        <thead>
        <tr>
            <th>ID</th>
            <th>Legal Name</th>
            <th>Trading Name</th>
            <th>Type</th>
            <th>ABN</th>
            <th>Employer ID</th>
            <th>Worksite Address</th>
            <th>Worksite State</th>
        </tr>
        </thead>
        <tbody>
        <!-- Organisation data will be inserted here -->
        </tbody>
    </table>
</div>

<div id="Relationships" class="tabcontent">
    <h3>Relationships</h3>
    <p>This tab displays the various relationships</p>
    <button onclick="document.getElementById('import-relationships-input').click()">Import from CSV</button>
    <input type="file" id="import-relationships-input" onchange="importRelationships(this.files[0])"
           style="display: none;" accept=".csv">
    <button onclick="exportRelationships()">Export to CSV</button>
    <table id="relationships-table">
        <thead>
        <tr>
            <th>ID</th>
            <th>Created At</th>
            <th>Last Confirmed At</th>
            <th>Ended At</th>
            <th>Primary Party</th>
            <th>Related Parties</th>
            <th>Type</th>
        </tr>
        </thead>
        <tbody>
        <!-- Relationship data will be inserted here -->
        </tbody>
    </table>
</div>

<div id="Interactions" class="tabcontent">
    <h3>Interactions</h3>
    <p>This tab displays interactions. The API to fetch interactions supports filtering on <code>profileId</code>,
        <code>contactId</code>, <code>createdAt</code>, and <code>interactionType</code>. The
        <code>interactionType</code> and <code>createdAt</code> query filters can be used together to fetch all
        "register interest" interaction since a particular date.</p>
    <p>
        If the contact/person doesn't already exist in the system, it will be created automatically (minted) when
        importing.

        If the profile doesn't already exist, it will also be created automatically and linked to the contact/person.
        The profile type will depend on the type of interaction.
    </p>
    <p>
        Note that the <code>payload</code> field is a JSON object and may contain commas, which may interfere with
        CSV parsing. The import/export functions handle this by stringifying the JSON object when exporting and
        parsing it back when importing.
    </p>
    <button onclick="document.getElementById('import-interactions-input').click()">Import from CSV</button>
    <input type="file" id="import-interactions-input" onchange="importInteractions(this.files[0])"
           style="display: none;" accept=".csv">
    <button onclick="exportInteractions()">Export to CSV</button>
    <table id="interactions-table">
        <thead>
        <tr>
            <th>ID</th>
            <th>Created At</th>
            <th>Contact ID</th>
            <th>Profile ID</th>
            <th>Interaction Type</th>
            <th>Payload</th>
        </tr>
        </thead>
        <tbody>
        <!-- Interaction data will be inserted here -->
        </tbody>
    </table>
</div>

<script>
    document.getElementById("defaultOpen").click();

    function openTab(evt, cityName) {
        // Declare all variables
        var i, tabcontent, tablinks;

        // Get all elements with class="tabcontent" and hide them
        tabcontent = document.getElementsByClassName("tabcontent");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
        }

        // Get all elements with class="tablinks" and remove the class "active"
        tablinks = document.getElementsByClassName("tablinks");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }

        // Show the current tab, and add an "active" class to the button that opened the tab
        document.getElementById(cityName).style.display = "block";
        evt.currentTarget.className += " active";
    }
</script>
<script>
    let organisationData = []; // To store fetched organisations
    let interactionData = []; // To store fetched interactions
    let relationshipData = []; // To store fetched relationships
    let contactData = []; // To store fetched contacts

    function downloadCSV(data, filename) {
        const csvRows = [];
        // Get the headers
        const headers = Object.keys(data[0]);
        csvRows.push(headers.join(','));

        // Loop over the rows
        for (const row of data) {
            const values = headers.map(header => {
                let value = '' + row[header]; // Ensure value is a string
                const needsQuotes = value.includes(',') || value.includes('"') || value.includes('\n') || value.includes('\r');
                value = value.replace(/"/g, '""'); // Escape double quotes
                if (needsQuotes) {
                    return `"${value}"`;
                } else {
                    return value;
                }
            });
            csvRows.push(values.join(','));
        }

        const blob = new Blob([csvRows.join('\n')], {type: 'text/csv'});
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.setAttribute('hidden', '');
        a.setAttribute('href', url);
        a.setAttribute('download', filename);
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    function parseCSV(csv) {
        const lines = csv.split('\n');
        const result = [];
        const headers = lines[0].match(/(".*?"|[^,]+)(?=\s*,|\s*$)/g).map(h => h.trim().replace(/^"|"$/g, ''));

        for (let i = 1; i < lines.length; i++) {
            if (!lines[i]) continue;
            const obj = {};
            // handle commas within quoted fields. TODO replace with a library
            const currentline = lines[i].match(/(?:^|,)(?:"((?:[^"]|"")*)"|([^",\r\n]*))/g);
            if (!currentline) continue;
            for (let j = 0; j < headers.length; j++) {
                // TODO this was just a quick fix to the incorrect regex provided by a quick search. Use a proper CSV parser library
                let s = currentline[j].trim().replace(/^"|"$/g, '').replace(/""/g, '"').replace(/^,/, '').replace(/^"/g, '');
                obj[headers[j]] = s;
            }
            result.push(obj);
        }
        return result;
    }


    function uploadCSV(file, onUpload) {
        const reader = new FileReader();
        reader.onload = function (e) {
            const text = e.target.result;
            const data = parseCSV(text);
            onUpload(data);
        };
        reader.readAsText(file);
    }

    async function importOrganisations(file) {
        if (!file) return;

        uploadCSV(file, async (organisations) => {
            // The CSV data is flattened, we need to un-flatten it to match the API
            const unflattenedData = organisations.map(org => ({
                legalName: org.legalName,
                tradingName: org.tradingName,
                organisationType: org.organisationType,
                abn: org.abn,
                employer: org.employerId ? {employerId: org.employerId} : null,
                worksite: (org.worksiteAddress || org.worksiteState) ? {
                    address: org.worksiteAddress,
                    state: org.worksiteState
                } : null
            }));

            try {
                const response = await fetch('/api/v1/organisations/bulk', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(unflattenedData)
                });

                if (response.ok) {
                    alert('Organisations imported successfully!');
                    fetchOrganisations(); // Refresh the table
                } else {
                    const error = await response.json();
                    alert('Error importing organisations: ' + (error.message || 'Unknown error'));
                    console.error('Error importing organisations:', error);
                }
            } catch (error) {
                alert('Error importing organisations: ' + error.message);
                console.error('Error importing organisations:', error);
            }
        });
    }

    async function exportOrganisations() {
        // We can use the already fetched data. If not available, fetch it.
        if (organisationData.length === 0) {
            await fetchOrganisations();
        }

        // Flatten the data for CSV export
        const flattenedData = organisationData.map(org => ({
            id: org.id,
            legalName: org.legalName,
            tradingName: org.tradingName,
            organisationType: org.organisationType,
            abn: org.abn,
            employerId: org.employer ? org.employer.employerId : '',
            worksiteAddress: org.worksite ? org.worksite.address : '',
            worksiteState: org.worksite ? org.worksite.state : ''
        }));

        downloadCSV(flattenedData, 'organisations.csv');
    }

    async function fetchOrganisations() {
        const organisationsTable = document.querySelector('#organisations-table tbody');
        try {
            const response = await fetch('/api/v1/organisations');
            if (response.ok) {
                const organisationList = await response.json();
                organisationData = organisationList.entries; // Store the data

                // Clear existing rows
                organisationsTable.innerHTML = '';

                organisationData.forEach(org => {
                    const row = organisationsTable.insertRow();
                    row.insertCell().textContent = org.id;
                    row.insertCell().textContent = org.legalName;
                    row.insertCell().textContent = org.tradingName;
                    row.insertCell().textContent = org.organisationType;
                    row.insertCell().textContent = org.abn;
                    row.insertCell().textContent = org.employer ? org.employer.employerId : '';
                    row.insertCell().textContent = org.worksite ? org.worksite.address : '';
                    row.insertCell().textContent = org.worksite ? org.worksite.state : '';
                });
            }
        } catch (error) {
            console.error('Error fetching organisations:', error);
        }
    }

    async function importInteractions(file) {
        alert('Interactions!');
        if (!file) return;

        uploadCSV(file, async (interactions) => {
            const interactionsToImport = interactions.map(interaction => ({
                createdAt: interaction.createdAt,
                contactId: interaction.contactId,
                profileId: interaction.profileId,
                interactionType: interaction.interactionType,
                payload: JSON.parse(interaction.payload) // Assuming payload is a JSON string in the CSV
            }));

            try {
                const response = await fetch('/api/v1/interactions/bulk', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(interactionsToImport)
                });

                if (response.ok) {
                    alert('Interactions imported successfully!');
                    fetchInteractions(); // Refresh the table
                } else {
                    const error = await response.json();
                    alert('Error importing interactions: ' + (error.message || 'Unknown error'));
                    console.error('Error importing interactions:', error);
                }
            } catch (error) {
                alert('Error importing interactions: ' + error.message);
                console.error('Error importing interactions:', error);
            }
        });
    }

    async function exportInteractions() {
        if (interactionData.length === 0) {
            await fetchInteractions();
        }

        const dataToExport = interactionData.map(interaction => ({
            id: interaction.id,
            createdAt: interaction.createdAt,
            contactId: interaction.contactId,
            profileId: interaction.profileId,
            interactionType: interaction.interactionType,
            payload: JSON.stringify(interaction.payload)
        }));

        downloadCSV(dataToExport, 'interactions.csv');
    }

    async function fetchInteractions() {
        const interactionsTable = document.querySelector('#interactions-table tbody');
        try {
            const response = await fetch('/api/v1/interactions');
            if (response.ok) {
                const interactionList = await response.json();
                interactionData = interactionList.entries; // Store the data

                // Clear existing rows
                interactionsTable.innerHTML = '';

                interactionData.forEach(interaction => {
                    const row = interactionsTable.insertRow();
                    row.insertCell().textContent = interaction.id;
                    row.insertCell().textContent = interaction.createdAt;
                    row.insertCell().textContent = interaction.contactId;
                    row.insertCell().textContent = interaction.profileId;
                    row.insertCell().textContent = interaction.interactionType;
                    row.insertCell().textContent = JSON.stringify(interaction.payload);
                });
            }
        } catch (error) {
            console.error('Error fetching interactions:', error);
        }
    }

    async function importRelationships(file) {
        if (!file) return;

        uploadCSV(file, async (relationships) => {
            const relationshipsToImport = relationships.map(relationship => ({
                createdAt: relationship.createdAt,
                lastConfirmAt: relationship.lastConfirmAt,
                endedAt: relationship.endedAt,
                primaryParty: relationship.primaryParty,
                relatedParties: relationship.relatedParties.split('|'), // Assuming they are pipe-separated in the CSV
                type: relationship.type
            }));

            try {
                const response = await fetch('/api/v1/relationships/bulk', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(relationshipsToImport)
                });

                if (response.ok) {
                    alert('Relationships imported successfully!');
                    fetchRelationships(); // Refresh the table
                } else {
                    const error = await response.json();
                    alert('Error importing relationships: ' + (error.message || 'Unknown error'));
                    console.error('Error importing relationships:', error);
                }
            } catch (error) {
                alert('Error importing relationships: ' + error.message);
                console.error('Error importing relationships:', error);
            }
        });
    }

    async function exportRelationships() {
        if (relationshipData.length === 0) {
            await fetchRelationships();
        }

        const dataToExport = relationshipData.map(relationship => ({
            id: relationship.id,
            createdAt: relationship.createdAt,
            lastConfirmAt: relationship.lastConfirmAt,
            endedAt: relationship.endedAt,
            primaryParty: relationship.primaryParty,
            relatedParties: relationship.relatedParties.join('|'), // Pipe-separate for CSV
            type: relationship.type
        }));

        downloadCSV(dataToExport, 'relationships.csv');
    }

    async function fetchRelationships() {
        const relationshipsTable = document.querySelector('#relationships-table tbody');
        try {
            const response = await fetch('/api/v1/relationships');
            if (response.ok) {
                const relationshipList = await response.json();
                relationshipData = relationshipList.entries; // Store the data

                // Clear existing rows
                relationshipsTable.innerHTML = '';

                relationshipData.forEach(relationship => {
                    const row = relationshipsTable.insertRow();
                    row.insertCell().textContent = relationship.id;
                    row.insertCell().textContent = relationship.createdAt;
                    row.insertCell().textContent = relationship.lastConfirmAt;
                    row.insertCell().textContent = relationship.endedAt;
                    row.insertCell().textContent = relationship.primaryParty;
                    row.insertCell().textContent = relationship.relatedParties.join(', ');
                    row.insertCell().textContent = relationship.type;
                });
            }
        } catch (error) {
            console.error('Error fetching relationships:', error);
        }
    }

    async function exportContacts() {
        if (contactData.length === 0) {
            await fetchContacts();
        }

        const flattenedData = [];
        contactData.forEach(contact => {
            if (contact.profiles && contact.profiles.length > 0) {
                contact.profiles.forEach(profile => {
                    flattenedData.push({
                        contactId: contact.id,
                        firstName: contact.firstName,
                        lastName: contact.lastName,
                        email: contact.email,
                        phone: contact.phone,
                        createdAt: contact.createdAt,
                        lastSeenAt: contact.lastSeenAt,
                        USI: contact.USI,
                        LUI: contact.LUI,
                        TFN: contact.TFN,
                        VSN: contact.VSN,
                        WorkReadyParticipantNumber: contact.WorkReadyParticipantNumber,
                        SACEStudentId: contact.SACEStudentId,
                        profileId: profile.id,
                        profileType: profile.type,
                        startedAt: profile.startedAt,
                        completedAt: profile.completedAt,
                        isActive: profile.isActive,
                        profileInformation: JSON.stringify(profile.profileInformation)
                    });
                });
            } else {
                flattenedData.push({
                    contactId: contact.id,
                    firstName: contact.firstName,
                    lastName: contact.lastName,
                    email: contact.email,
                    phone: contact.phone,
                    createdAt: contact.createdAt,
                    lastSeenAt: contact.lastSeenAt,
                    USI: contact.USI,
                    LUI: contact.LUI,
                    TFN: contact.TFN,
                    VSN: contact.VSN,
                    WorkReadyParticipantNumber: contact.WorkReadyParticipantNumber,
                    SACEStudentId: contact.SACEStudentId,
                    profileId: '',
                    profileType: '',
                    startedAt: '',
                    completedAt: '',
                    isActive: '',
                    profileInformation: ''
                });
            }
        });

        downloadCSV(flattenedData, 'contacts.csv');
    }

    async function exportAnalyses() {
        if (contactData.length === 0) {
            await fetchContacts();
        }

        const flattenedData = [];
        contactData.forEach(contact => {
            if (contact.analyses && contact.analyses.length > 0) {
                contact.analyses.forEach(analysis => {
                    flattenedData.push({
                        contactId: contact.id,
                        firstName: contact.firstName,
                        lastName: contact.lastName,
                        analysisId: analysis.id,
                        analysisType: analysis.type,
                        analysisDate: analysis.date,
                        analysisResult: JSON.stringify(analysis.result),
                        analysisNotes: analysis.notes
                    });
                });
            } else {
                // Include contacts with no analyses, but with empty analysis fields
                flattenedData.push({
                    contactId: contact.id,
                    firstName: contact.firstName,
                    lastName: contact.lastName,
                    analysisId: '',
                    analysisType: '',
                    analysisDate: '',
                    analysisResult: '',
                    analysisNotes: ''
                });
            }
        });
        downloadCSV(flattenedData, 'analyses.csv');
    }

    async function fetchContacts() {
        const contactsTable = document.querySelector('#contacts-table tbody');
        try {
            const response = await fetch('/api/v1/contacts');
            if (response.ok) {
                const contactList = await response.json();
                contactData = contactList.entries; // Store the data

                // Clear existing rows
                contactsTable.innerHTML = '';

                contactData.forEach(contact => {
                    const numProfiles = contact.profiles ? contact.profiles.length : 0;

                    if (numProfiles === 0) {
                        const row = contactsTable.insertRow();
                        row.insertCell().textContent = contact.id;
                        row.insertCell().textContent = contact.firstName;
                        row.insertCell().textContent = contact.lastName;
                        row.insertCell().textContent = contact.email;
                        row.insertCell().textContent = contact.phone;
                        row.insertCell().textContent = contact.createdAt;
                        row.insertCell().textContent = contact.lastSeenAt;
                        row.insertCell().textContent = contact.USI;
                        row.insertCell().textContent = contact.LUI;
                        row.insertCell().textContent = contact.TFN;
                        row.insertCell().textContent = contact.VSN;
                        row.insertCell().textContent = contact.WorkReadyParticipantNumber;
                        row.insertCell().textContent = contact.SACEStudentId;
                        row.insertCell().textContent = ''; // No profile ID
                        row.insertCell().textContent = ''; // No profile Type
                        row.insertCell().textContent = ''; // No startedAt
                        row.insertCell().textContent = ''; // No completedAt
                        row.insertCell().textContent = ''; // No isActive
                        row.insertCell().textContent = ''; // No profileInformation
                    } else {
                        contact.profiles.forEach((profile, index) => {
                            const row = contactsTable.insertRow();
                            if (index === 0) {
                                // For the first profile, add contact details with rowspan
                                const idCell = row.insertCell();
                                idCell.textContent = contact.id;
                                idCell.rowSpan = numProfiles;

                                const firstNameCell = row.insertCell();
                                firstNameCell.textContent = contact.firstName;
                                firstNameCell.rowSpan = numProfiles;

                                const lastNameCell = row.insertCell();
                                lastNameCell.textContent = contact.lastName;
                                lastNameCell.rowSpan = numProfiles;

                                const emailCell = row.insertCell();
                                emailCell.textContent = contact.email;
                                emailCell.rowSpan = numProfiles;

                                const phoneCell = row.insertCell();
                                phoneCell.textContent = contact.phone;
                                phoneCell.rowSpan = numProfiles;

                                const createdAtCell = row.insertCell();
                                createdAtCell.textContent = contact.createdAt;
                                createdAtCell.rowSpan = numProfiles;

                                const lastSeenAtCell = row.insertCell();
                                lastSeenAtCell.textContent = contact.lastSeenAt;
                                lastSeenAtCell.rowSpan = numProfiles;

                                const USICell = row.insertCell();
                                USICell.textContent = contact.USI;
                                USICell.rowSpan = numProfiles;

                                const LUICell = row.insertCell();
                                LUICell.textContent = contact.LUI;
                                LUICell.rowSpan = numProfiles;

                                const TFNCell = row.insertCell();
                                TFNCell.textContent = contact.TFN;
                                TFNCell.rowSpan = numProfiles;

                                const VSNCell = row.insertCell();
                                VSNCell.textContent = contact.VSN;
                                VSNCell.rowSpan = numProfiles;

                                const WRPNCell = row.insertCell();
                                WRPNCell.textContent = contact.WorkReadyParticipantNumber;
                                WRPNCell.rowSpan = numProfiles;

                                const SACECell = row.insertCell();
                                SACECell.textContent = contact.SACEStudentId;
                                SACECell.rowSpan = numProfiles;
                            }
                            // Add profile details for every profile
                            row.insertCell().textContent = profile.id;
                            row.insertCell().textContent = profile.type;
                            row.insertCell().textContent = profile.startedAt;
                            row.insertCell().textContent = profile.completedAt;
                            row.insertCell().textContent = profile.isActive;
                            row.insertCell().textContent = JSON.stringify(profile.profileInformation);
                        });
                    }
                });
            }
        } catch (error) {
            console.error('Error fetching contacts:', error);
        }
    }

    async function fetchAnalyses() {
        const analysesTable = document.querySelector('#analyses-table tbody');
        analysesTable.innerHTML = ''; // Clear existing rows

        contactData.forEach(contact => {
            const numAnalyses = contact.analyses ? contact.analyses.length : 0;

            if (numAnalyses === 0) {
                // If no analyses, still show contact info with empty analysis fields
                const row = analysesTable.insertRow();
                row.insertCell().textContent = contact.id;
                row.insertCell().textContent = contact.firstName;
                row.insertCell().textContent = contact.lastName;
                row.insertCell().textContent = ''; // Analysis ID
                row.insertCell().textContent = ''; // Type
                row.insertCell().textContent = ''; // Date
                row.insertCell().textContent = ''; // Result
                row.insertCell().textContent = ''; // Notes
            } else {
                contact.analyses.forEach((analysis, index) => {
                    const row = analysesTable.insertRow();
                    if (index === 0) {
                        // For the first analysis, add contact details with rowspan
                        const idCell = row.insertCell();
                        idCell.textContent = contact.id;
                        idCell.rowSpan = numAnalyses;

                        const firstNameCell = row.insertCell();
                        firstNameCell.textContent = contact.firstName;
                        firstNameCell.rowSpan = numAnalyses;

                        const lastNameCell = row.insertCell();
                        lastNameCell.textContent = contact.lastName;
                        lastNameCell.rowSpan = numAnalyses;
                    }
                    // Add analysis details for every analysis
                    row.insertCell().textContent = analysis.id;
                    row.insertCell().textContent = analysis.type;
                    row.insertCell().textContent = analysis.date;
                    row.insertCell().textContent = JSON.stringify(analysis.result);
                    row.insertCell().textContent = analysis.notes;
                });
            }
        });
    }

    async function fetchSystemLinks() {
        const systemLinksTable = document.querySelector('#system-links-table tbody');
        systemLinksTable.innerHTML = ''; // Clear existing rows

        contactData.forEach(contact => {
            const numSystemLinks = contact.systemLinks ? contact.systemLinks.length : 0;

            if (numSystemLinks === 0) {
                // If no system links, still show contact info with empty system link fields
                const row = systemLinksTable.insertRow();
                row.insertCell().textContent = contact.id;
                row.insertCell().textContent = contact.firstName;
                row.insertCell().textContent = contact.lastName;
                row.insertCell().textContent = ''; // System Link ID
                row.insertCell().textContent = ''; // System Name
                row.insertCell().textContent = ''; // System ID
                row.insertCell().textContent = ''; // URL
            } else {
                contact.systemLinks.forEach((systemLink, index) => {
                    const row = systemLinksTable.insertRow();
                    if (index === 0) {
                        // For the first system link, add contact details with rowspan
                        const idCell = row.insertCell();
                        idCell.textContent = contact.id;
                        idCell.rowSpan = numSystemLinks;

                        const firstNameCell = row.insertCell();
                        firstNameCell.textContent = contact.firstName;
                        firstNameCell.rowSpan = numSystemLinks;

                        const lastNameCell = row.insertCell();
                        lastNameCell.textContent = contact.lastName;
                        lastNameCell.rowSpan = numSystemLinks;
                    }
                    // Add system link details for every system link
                    row.insertCell().textContent = systemLink.id;
                    row.insertCell().textContent = systemLink.systemName;
                    row.insertCell().textContent = systemLink.systemId;
                    row.insertCell().textContent = systemLink.url;
                });
            }
        });
    }

    async function exportSystemLinks() {
        if (contactData.length === 0) {
            await fetchContacts();
        }

        const flattenedData = [];
        contactData.forEach(contact => {
            if (contact.systemLinks && contact.systemLinks.length > 0) {
                contact.systemLinks.forEach(systemLink => {
                    flattenedData.push({
                        contactId: contact.id,
                        firstName: contact.firstName,
                        lastName: contact.lastName,
                        systemLinkId: systemLink.id,
                        systemName: systemLink.systemName,
                        systemId: systemLink.systemId,
                        url: systemLink.url
                    });
                });
            } else {
                // Include contacts with no system links, but with empty system link fields
                flattenedData.push({
                    contactId: contact.id,
                    firstName: contact.firstName,
                    lastName: contact.lastName,
                    systemLinkId: '',
                    systemName: '',
                    systemId: '',
                    url: ''
                });
            }
        });
        downloadCSV(flattenedData, 'system_links.csv');
    }

    document.addEventListener('DOMContentLoaded', () => {
        fetchOrganisations();
        fetchInteractions();
        fetchRelationships();
        fetchContacts().then(() => {
            fetchAnalyses(); // Call fetchAnalyses after contacts are fetched
            fetchSystemLinks(); // Call fetchSystemLinks after contacts are fetched
        });
    });
</script>
</body>
</html>
